{"ast":null,"code":"const {\n  inspect\n} = require('util');\nconst isObject = require('../help/is_object');\nconst {\n  generate,\n  generateSync\n} = require('../jwk/generate');\nconst {\n  USES_MAPPING\n} = require('../help/consts');\nconst {\n  isKey,\n  asKey: importKey\n} = require('../jwk');\nconst keyscore = (key, _ref) => {\n  let {\n    alg,\n    use,\n    ops\n  } = _ref;\n  let score = 0;\n  if (alg && key.alg) {\n    score++;\n  }\n  if (use && key.use) {\n    score++;\n  }\n  if (ops && key.key_ops) {\n    score++;\n  }\n  return score;\n};\nclass KeyStore {\n  constructor() {\n    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {\n      keys[_key] = arguments[_key];\n    }\n    while (keys.some(Array.isArray)) {\n      keys = keys.flat ? keys.flat() : keys.reduce((acc, val) => {\n        if (Array.isArray(val)) {\n          return [...acc, ...val];\n        }\n        acc.push(val);\n        return acc;\n      }, []);\n    }\n    if (keys.some(k => !isKey(k) || !k.kty)) {\n      throw new TypeError('all keys must be instances of a key instantiated by JWK.asKey');\n    }\n    this._keys = new Set(keys);\n  }\n  all() {\n    let {\n      alg,\n      kid,\n      thumbprint,\n      use,\n      kty,\n      key_ops: ops,\n      x5t,\n      'x5t#S256': x5t256,\n      crv\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (ops !== undefined && (!Array.isArray(ops) || !ops.length || ops.some(x => typeof x !== 'string'))) {\n      throw new TypeError('`key_ops` must be a non-empty array of strings');\n    }\n    const search = {\n      alg,\n      use,\n      ops\n    };\n    return [...this._keys].filter(key => {\n      let candidate = true;\n      if (candidate && kid !== undefined && key.kid !== kid) {\n        candidate = false;\n      }\n      if (candidate && thumbprint !== undefined && key.thumbprint !== thumbprint) {\n        candidate = false;\n      }\n      if (candidate && x5t !== undefined && key.x5t !== x5t) {\n        candidate = false;\n      }\n      if (candidate && x5t256 !== undefined && key['x5t#S256'] !== x5t256) {\n        candidate = false;\n      }\n      if (candidate && kty !== undefined && key.kty !== kty) {\n        candidate = false;\n      }\n      if (candidate && crv !== undefined && key.crv !== crv) {\n        candidate = false;\n      }\n      if (alg !== undefined && !key.algorithms().has(alg)) {\n        candidate = false;\n      }\n      if (candidate && use !== undefined && key.use !== undefined && key.use !== use) {\n        candidate = false;\n      }\n\n      // TODO:\n      if (candidate && ops !== undefined && (key.key_ops !== undefined || key.use !== undefined)) {\n        let keyOps;\n        if (key.key_ops) {\n          keyOps = new Set(key.key_ops);\n        } else {\n          keyOps = USES_MAPPING[key.use];\n        }\n        if (ops.some(x => !keyOps.has(x))) {\n          candidate = false;\n        }\n      }\n      return candidate;\n    }).sort((first, second) => keyscore(second, search) - keyscore(first, search));\n  }\n  get() {\n    return this.all(...arguments)[0];\n  }\n  add(key) {\n    if (!isKey(key) || !key.kty) {\n      throw new TypeError('key must be an instance of a key instantiated by JWK.asKey');\n    }\n    this._keys.add(key);\n  }\n  remove(key) {\n    if (!isKey(key)) {\n      throw new TypeError('key must be an instance of a key instantiated by JWK.asKey');\n    }\n    this._keys.delete(key);\n  }\n  toJWKS() {\n    let priv = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return {\n      keys: [...this._keys.values()].map(key => key.toJWK(priv && (key.private || key.secret && key.k)))\n    };\n  }\n  async generate() {\n    this._keys.add(await generate(...arguments));\n  }\n  generateSync() {\n    this._keys.add(generateSync(...arguments));\n  }\n  get size() {\n    return this._keys.size;\n  }\n\n  /* c8 ignore next 8 */\n  [inspect.custom]() {\n    return `${this.constructor.name} ${inspect(this.toJWKS(false), {\n      depth: Infinity,\n      colors: process.stdout.isTTY,\n      compact: false,\n      sorted: true\n    })}`;\n  }\n  *[Symbol.iterator]() {\n    for (const key of this._keys) {\n      yield key;\n    }\n  }\n}\nfunction asKeyStore(jwks) {\n  let {\n    ignoreErrors = false,\n    calculateMissingRSAPrimes = false\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!isObject(jwks) || !Array.isArray(jwks.keys) || jwks.keys.some(k => !isObject(k) || !('kty' in k))) {\n    throw new TypeError('jwks must be a JSON Web Key Set formatted object');\n  }\n  const keys = jwks.keys.map(jwk => {\n    try {\n      return importKey(jwk, {\n        calculateMissingRSAPrimes\n      });\n    } catch (err) {\n      if (!ignoreErrors) {\n        throw err;\n      }\n      return undefined;\n    }\n  }).filter(Boolean);\n  return new KeyStore(...keys);\n}\nmodule.exports = {\n  KeyStore,\n  asKeyStore\n};","map":{"version":3,"names":["inspect","require","isObject","generate","generateSync","USES_MAPPING","isKey","asKey","importKey","keyscore","key","alg","use","ops","score","key_ops","KeyStore","constructor","keys","some","Array","isArray","flat","reduce","acc","val","push","k","kty","TypeError","_keys","Set","all","kid","thumbprint","x5t","x5t256","crv","undefined","length","x","search","filter","candidate","algorithms","has","keyOps","sort","first","second","get","add","remove","delete","toJWKS","priv","values","map","toJWK","private","secret","size","custom","name","depth","Infinity","colors","process","stdout","isTTY","compact","sorted","Symbol","iterator","asKeyStore","jwks","ignoreErrors","calculateMissingRSAPrimes","jwk","err","Boolean","module","exports"],"sources":["/Users/justinas/Documents/repos/microgogool/client/node_modules/jose/lib/jwks/keystore.js"],"sourcesContent":["const { inspect } = require('util')\n\nconst isObject = require('../help/is_object')\nconst { generate, generateSync } = require('../jwk/generate')\nconst { USES_MAPPING } = require('../help/consts')\nconst { isKey, asKey: importKey } = require('../jwk')\n\nconst keyscore = (key, { alg, use, ops }) => {\n  let score = 0\n\n  if (alg && key.alg) {\n    score++\n  }\n\n  if (use && key.use) {\n    score++\n  }\n\n  if (ops && key.key_ops) {\n    score++\n  }\n\n  return score\n}\n\nclass KeyStore {\n  constructor (...keys) {\n    while (keys.some(Array.isArray)) {\n      keys = keys.flat\n        ? keys.flat()\n        : keys.reduce((acc, val) => {\n          if (Array.isArray(val)) {\n            return [...acc, ...val]\n          }\n\n          acc.push(val)\n          return acc\n        }, [])\n    }\n    if (keys.some(k => !isKey(k) || !k.kty)) {\n      throw new TypeError('all keys must be instances of a key instantiated by JWK.asKey')\n    }\n\n    this._keys = new Set(keys)\n  }\n\n  all ({ alg, kid, thumbprint, use, kty, key_ops: ops, x5t, 'x5t#S256': x5t256, crv } = {}) {\n    if (ops !== undefined && (!Array.isArray(ops) || !ops.length || ops.some(x => typeof x !== 'string'))) {\n      throw new TypeError('`key_ops` must be a non-empty array of strings')\n    }\n\n    const search = { alg, use, ops }\n    return [...this._keys]\n      .filter((key) => {\n        let candidate = true\n\n        if (candidate && kid !== undefined && key.kid !== kid) {\n          candidate = false\n        }\n\n        if (candidate && thumbprint !== undefined && key.thumbprint !== thumbprint) {\n          candidate = false\n        }\n\n        if (candidate && x5t !== undefined && key.x5t !== x5t) {\n          candidate = false\n        }\n\n        if (candidate && x5t256 !== undefined && key['x5t#S256'] !== x5t256) {\n          candidate = false\n        }\n\n        if (candidate && kty !== undefined && key.kty !== kty) {\n          candidate = false\n        }\n\n        if (candidate && crv !== undefined && (key.crv !== crv)) {\n          candidate = false\n        }\n\n        if (alg !== undefined && !key.algorithms().has(alg)) {\n          candidate = false\n        }\n\n        if (candidate && use !== undefined && (key.use !== undefined && key.use !== use)) {\n          candidate = false\n        }\n\n        // TODO:\n        if (candidate && ops !== undefined && (key.key_ops !== undefined || key.use !== undefined)) {\n          let keyOps\n          if (key.key_ops) {\n            keyOps = new Set(key.key_ops)\n          } else {\n            keyOps = USES_MAPPING[key.use]\n          }\n          if (ops.some(x => !keyOps.has(x))) {\n            candidate = false\n          }\n        }\n\n        return candidate\n      })\n      .sort((first, second) => keyscore(second, search) - keyscore(first, search))\n  }\n\n  get (...args) {\n    return this.all(...args)[0]\n  }\n\n  add (key) {\n    if (!isKey(key) || !key.kty) {\n      throw new TypeError('key must be an instance of a key instantiated by JWK.asKey')\n    }\n\n    this._keys.add(key)\n  }\n\n  remove (key) {\n    if (!isKey(key)) {\n      throw new TypeError('key must be an instance of a key instantiated by JWK.asKey')\n    }\n\n    this._keys.delete(key)\n  }\n\n  toJWKS (priv = false) {\n    return {\n      keys: [...this._keys.values()].map(\n        key => key.toJWK(priv && (key.private || (key.secret && key.k)))\n      )\n    }\n  }\n\n  async generate (...args) {\n    this._keys.add(await generate(...args))\n  }\n\n  generateSync (...args) {\n    this._keys.add(generateSync(...args))\n  }\n\n  get size () {\n    return this._keys.size\n  }\n\n  /* c8 ignore next 8 */\n  [inspect.custom] () {\n    return `${this.constructor.name} ${inspect(this.toJWKS(false), {\n      depth: Infinity,\n      colors: process.stdout.isTTY,\n      compact: false,\n      sorted: true\n    })}`\n  }\n\n  * [Symbol.iterator] () {\n    for (const key of this._keys) {\n      yield key\n    }\n  }\n}\n\nfunction asKeyStore (jwks, { ignoreErrors = false, calculateMissingRSAPrimes = false } = {}) {\n  if (!isObject(jwks) || !Array.isArray(jwks.keys) || jwks.keys.some(k => !isObject(k) || !('kty' in k))) {\n    throw new TypeError('jwks must be a JSON Web Key Set formatted object')\n  }\n\n  const keys = jwks.keys.map((jwk) => {\n    try {\n      return importKey(jwk, { calculateMissingRSAPrimes })\n    } catch (err) {\n      if (!ignoreErrors) {\n        throw err\n      }\n      return undefined\n    }\n  }).filter(Boolean)\n\n  return new KeyStore(...keys)\n}\n\nmodule.exports = { KeyStore, asKeyStore }\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}